import { execSync } from "node:child_process";
import { resolve } from "node:path";
import { wrap, type AgentResult } from "@acme/agent-runtime";

const AGENT_NAME = "git-pr";
const PR_BODY = "Auto-generated by Agent Factory";
const BRANCH_NAME_PATTERN = /^[A-Za-z0-9._/-]+$/;

type Mode = "dry-run" | "pr-ready";

export type AgentInput = {
  branchName: string;
  commitMessage: string;
  patchedFiles: string[];
  mode: Mode;
  repoRoot: string;
};

export type AgentData = {
  commands: string[];
  executed: boolean;
  branchName: string;
};

function escapeDoubleQuoted(value: string): string {
  return value.replaceAll("\\", "\\\\").replaceAll('"', '\\"');
}

function validateBranchName(branchName: string): void {
  if (branchName.trim().length === 0) {
    throw new Error("invalid_branch_name: branchName must not be empty");
  }
  if (!BRANCH_NAME_PATTERN.test(branchName)) {
    throw new Error(
      "invalid_branch_name: branchName must only contain letters, numbers, '.', '-', '_' or '/'",
    );
  }
}

function buildCommands(input: AgentInput): string[] {
  const commitMessage = escapeDoubleQuoted(input.commitMessage);
  const commands = [`git checkout -b ${input.branchName}`];

  for (const filePath of input.patchedFiles) {
    commands.push(`git add ${filePath}`);
  }

  commands.push(`git commit -m "${commitMessage}"`);
  commands.push(`git push origin ${input.branchName}`);
  commands.push(`gh pr create --title "${commitMessage}" --body "${PR_BODY}"`);

  return commands;
}

function executeGitCommands(commands: string[], repoRootAbs: string): void {
  const gitCommands = commands.slice(0, 4);
  for (const command of gitCommands) {
    execSync(command, {
      cwd: repoRootAbs,
      encoding: "utf8",
      stdio: "pipe",
      windowsHide: true,
    });
  }
}

async function runImpl(input: AgentInput): Promise<AgentData> {
  validateBranchName(input.branchName);
  if (input.mode !== "dry-run" && input.mode !== "pr-ready") {
    throw new Error("invalid_mode: mode must be one of dry-run or pr-ready");
  }
  const commands = buildCommands(input);

  if (input.mode === "dry-run") {
    return {
      commands,
      executed: false,
      branchName: input.branchName,
    };
  }

  const repoRootAbs = resolve(process.cwd(), input.repoRoot);
  executeGitCommands(commands, repoRootAbs);

  return {
    commands,
    executed: true,
    branchName: input.branchName,
  };
}

export async function run(input: AgentInput): Promise<AgentResult<AgentData>> {
  return wrap<AgentInput, AgentData>(AGENT_NAME, runImpl, input);
}
